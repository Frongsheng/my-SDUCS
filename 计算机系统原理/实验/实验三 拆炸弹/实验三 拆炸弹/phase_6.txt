b* 0x4016e0
r
//node[] = {0fd, 2d5, 12d, 3e5, 0d4, 1b0}
x $v1 //node[i]
c
x $v1
c
x $v1
c
x $v1
c
x $v1
c
x $v1
c



00401500 <phase_6>:
  401500:	27bdffa0 	addiu	sp,sp,-96
  401504:	afbf005c 	sw	ra,92(sp)
  401508:	afbe0058 	sw	s8,88(sp)
  40150c:	03a0f021 	move	s8,sp
  401510:	3c1c0042 	lui	gp,0x42
  401514:	279cb190 	addiu	gp,gp,-20080
  401518:	afbc0010 	sw	gp,16(sp)
  40151c:	afc40060 	sw	a0,96(s8)
  401520:	3c020041 	lui	v0,0x41
  401524:	24423130 	addiu	v0,v0,12592
  401528:	afc20020 	sw	v0,32(s8)
  40152c:	27c20024 	addiu	v0,s8,36
  401530:	8fc40060 	lw	a0,96(s8)
  401534:	00402821 	move	a1,v0
  401538:	0c1006ea 	jal	401ba8 <read_six_numbers> # 输入六个数字
  40153c:	00000000 	nop  # 第一层循环的初始条件设定
  401540:	8fdc0010 	lw	gp,16(s8)
  401544:	afc0001c 	sw	zero,28(s8) # i = 0
  401548:	1000003c 	b	40163c <phase_6+0x13c> # 跳至0x40163c处条件判断处
  40154c:	00000000 	nop # 第一层循环中间循环体开始
  401550:	8fc2001c 	lw	v0,28(s8) # 获取i
  401554:	00000000 	nop
  401558:	00021080 	sll	v0,v0,0x2 #拓至1int长度
  40155c:	27c30018 	addiu	v1,s8,24
  401560:	00621021 	addu	v0,v1,v0
  401564:	8c42000c 	lw	v0,12(v0) # 得到输入的第i个数
  401568:	00000000 	nop
  40156c:	28420007 	slti	v0,v0,7 # 判断第i个数是否小于7
  401570:	1040000a 	beqz	v0,40159c <phase_6+0x9c> # 否则引爆
  401574:	00000000 	nop
  401578:	8fc2001c 	lw	v0,28(s8)
  40157c:	00000000 	nop
  401580:	00021080 	sll	v0,v0,0x2
  401584:	27c30018 	addiu	v1,s8,24
  401588:	00621021 	addu	v0,v1,v0
  40158c:	8c42000c 	lw	v0,12(v0)
  401590:	00000000 	nop
  401594:	1c400004 	bgtz	v0,4015a8 <phase_6+0xa8> # 判断第i个数是否大于0，否则引爆
  401598:	00000000 	nop
  40159c:	0c10087c 	jal	4021f0 <explode_bomb>
  4015a0:	00000000 	nop
  4015a4:	8fdc0010 	lw	gp,16(s8)
  4015a8:	8fc2001c 	lw	v0,28(s8)
  4015ac:	00000000 	nop # 第二层循环的初始条件设定
  4015b0:	24420001 	addiu	v0,v0,1 # j  = i + 1
  4015b4:	afc20018 	sw	v0,24(s8) # 将j存至m[$s8 + 24]处
  4015b8:	10000017 	b	401618 <phase_6+0x118> # 跳至0x401618条件判断处
  4015bc:	00000000 	nop # 第二层循环中间循环体开始
  4015c0:	8fc2001c 	lw	v0,28(s8) # 获取i
  4015c4:	00000000 	nop
  4015c8:	00021080 	sll	v0,v0,0x2
  4015cc:	27c30018 	addiu	v1,s8,24
  4015d0:	00621021 	addu	v0,v1,v0
  4015d4:	8c43000c 	lw	v1,12(v0) # 获取第i个数
  4015d8:	8fc20018 	lw	v0,24(s8) # 获取j
  4015dc:	00000000 	nop
  4015e0:	00021080 	sll	v0,v0,0x2
  4015e4:	27c40018 	addiu	a0,s8,24
  4015e8:	00821021 	addu	v0,a0,v0
  4015ec:	8c42000c 	lw	v0,12(v0) # 获取第j个数
  4015f0:	00000000 	nop
  4015f4:	14620004 	bne	v1,v0,401608 <phase_6+0x108> #判断第i个数和第j个数是否不相等，否则爆炸
  4015f8:	00000000 	nop
  4015fc:	0c10087c 	jal	4021f0 <explode_bomb>
  401600:	00000000 	nop
  401604:	8fdc0010 	lw	gp,16(s8)
  401608:	8fc20018 	lw	v0,24(s8)
  40160c:	00000000 	nop # 第二层循环末尾循环体
  401610:	24420001 	addiu	v0,v0,1 # j++
  401614:	afc20018 	sw	v0,24(s8)
  401618:	8fc20018 	lw	v0,24(s8) # 第二层循环条件判断处
  40161c:	00000000 	nop
  401620:	28420006 	slti	v0,v0,6 # 当j < 6时，继续循环
  401624:	1440ffe6 	bnez	v0,4015c0 <phase_6+0xc0>
  401628:	00000000 	nop
  40162c:	8fc2001c 	lw	v0,28(s8) # 获取i
  401630:	00000000 	nop # 第一层循环末尾循环体
  401634:	24420001 	addiu	v0,v0,1 # i++
  401638:	afc2001c 	sw	v0,28(s8)
  40163c:	8fc2001c 	lw	v0,28(s8) # 第一层循环条件判断处
  401640:	00000000 	nop
  401644:	28420006 	slti	v0,v0,6 # 当i < 6 时，继续循环
  401648:	1440ffc1 	bnez	v0,401550 <phase_6+0x50>
  40164c:	00000000 	nop # 第一层循环的初始条件 
  401650:	afc0001c 	sw	zero,28(s8) # i = 0
  401654:	10000028 	b	4016f8 <phase_6+0x1f8> # 跳至条件判断处
  401658:	00000000 	nop # 第二层循环的初始条件
  40165c:	3c020041 	lui	v0,0x41
  401660:	24423130 	addiu	v0,v0,12592 # 令$v0等于&firstnode = 0x413130
  401664:	afc20020 	sw	v0,32(s8) # m[$s8 + 32] = &firstnode
  401668:	24020001 	li	v0,1 # j = 1
  40166c:	afc20018 	sw	v0,24(s8)
  401670:	1000000a 	b	40169c <phase_6+0x19c> # 跳至条件判断处
  401674:	00000000 	nop
  401678:	8fc20020 	lw	v0,32(s8) # 取得&node
  40167c:	00000000 	nop
  401680:	8c420008 	lw	v0,8(v0) #  $v0 = m[$v0 + 8]
  401684:	00000000 	nop
  401688:	afc20020 	sw	v0,32(s8) # node = node->next
  40168c:	8fc20018 	lw	v0,24(s8) # 取得j
  401690:	00000000 	nop
  401694:	24420001 	addiu	v0,v0,1 # j++
  401698:	afc20018 	sw	v0,24(s8)
  40169c:	8fc2001c 	lw	v0,28(s8) # 取得i
  4016a0:	00000000 	nop
  4016a4:	00021080 	sll	v0,v0,0x2
  4016a8:	27c30018 	addiu	v1,s8,24
  4016ac:	00621021 	addu	v0,v1,v0
  4016b0:	8c43000c 	lw	v1,12(v0) # 取得输入的第i个数
  4016b4:	8fc20018 	lw	v0,24(s8)
  4016b8:	00000000 	nop
  4016bc:	0043102a 	slt	v0,v0,v1 # 判断j是否小于输入的第i个数，是则循环继续
  4016c0:	1440ffed 	bnez	v0,401678 <phase_6+0x178>
  4016c4:	00000000 	nop
  4016c8:	8fc2001c 	lw	v0,28(s8) # 取得i
  4016cc:	00000000 	nop
  4016d0:	00021080 	sll	v0,v0,0x2
  4016d4:	27c30018 	addiu	v1,s8,24
  4016d8:	00621021 	addu	v0,v1,v0
  4016dc:	8fc30020 	lw	v1,32(s8) # 将node = [链表的第j/【输入的第i个数】个取出
  4016e0:	00000000 	nop
  4016e4:	ac430024 	sw	v1,36(v0) # 存入数组res的res[i]中
  4016e8:	8fc2001c 	lw	v0,28(s8)
  4016ec:	00000000 	nop
  4016f0:	24420001 	addiu	v0,v0,1
  4016f4:	afc2001c 	sw	v0,28(s8)
  4016f8:	8fc2001c 	lw	v0,28(s8) # 条件判断处
  4016fc:	00000000 	nop
  401700:	28420006 	slti	v0,v0,6 # i < 6 则循环继续
  401704:	1440ffd5 	bnez	v0,40165c <phase_6+0x15c>
  401708:	00000000 	nop
  40170c:	8fc2003c 	lw	v0,60(s8)
  401710:	00000000 	nop
  401714:	afc20020 	sw	v0,32(s8) # node = firstnode 
  401718:	24020001 	li	v0,1
  40171c:	afc2001c 	sw	v0,28(s8) # i = 1
  401720:	10000016 	b	40177c <phase_6+0x27c>
  401724:	00000000 	nop # 循环开始
  401728:	8fc2001c 	lw	v0,28(s8) # 取得i
  40172c:	00000000 	nop
  401730:	00021080 	sll	v0,v0,0x2
  401734:	27c30018 	addiu	v1,s8,24
  401738:	00621021 	addu	v0,v1,v0
  40173c:	8c430024 	lw	v1,36(v0) # 取得res[i]
  401740:	8fc20020 	lw	v0,32(s8) # 取得node
  401744:	00000000 	nop
  401748:	ac430008 	sw	v1,8(v0) # node->next = res[i]
  40174c:	8fc2001c 	lw	v0,28(s8) # 取得i
  401750:	00000000 	nop
  401754:	00021080 	sll	v0,v0,0x2
  401758:	27c30018 	addiu	v1,s8,24
  40175c:	00621021 	addu	v0,v1,v0
  401760:	8c420024 	lw	v0,36(v0) # 取得res[i]
  401764:	00000000 	nop
  401768:	afc20020 	sw	v0,32(s8) # node = res[i]
  40176c:	8fc2001c 	lw	v0,28(s8) # 末尾循环体起始，取得i
  401770:	00000000 	nop
  401774:	24420001 	addiu	v0,v0,1 # i++
  401778:	afc2001c 	sw	v0,28(s8) # 存入内存中
  40177c:	8fc2001c 	lw	v0,28(s8) # 条件判断起始
  401780:	00000000 	nop
  401784:	28420006 	slti	v0,v0,6 # 判断i < 6，是则循环继续
  401788:	1440ffe7 	bnez	v0,401728 <phase_6+0x228>
  40178c:	00000000 	nop
  401790:	8fc20020 	lw	v0,32(s8)
  401794:	00000000 	nop
  401798:	ac400008 	sw	zero,8(v0) # node->next = null
  40179c:	8fc2003c 	lw	v0,60(s8)
  4017a0:	00000000 	nop
  4017a4:	afc20020 	sw	v0,32(s8) # node = firstnode
  4017a8:	afc0001c 	sw	zero,28(s8) # i = 0
  4017ac:	10000032 	b	401878 <phase_6+0x378>
  4017b0:	00000000 	nop
  4017b4:	8f82806c 	lw	v0,-32660(gp)
  4017b8:	00000000 	nop
  4017bc:	8c42002c 	lw	v0,44(v0)
  4017c0:	00000000 	nop
  4017c4:	30420001 	andi	v0,v0,0x1
  4017c8:	304200ff 	andi	v0,v0,0xff
  4017cc:	10400012 	beqz	v0,401818 <phase_6+0x318> # if...else语句，判断奇偶
  4017d0:	00000000 	nop
  4017d4:	8fc20020 	lw	v0,32(s8)
  4017d8:	00000000 	nop
  4017dc:	8c430000 	lw	v1,0(v0)
  4017e0:	8fc20020 	lw	v0,32(s8)
  4017e4:	00000000 	nop
  4017e8:	8c420008 	lw	v0,8(v0)
  4017ec:	00000000 	nop
  4017f0:	8c420000 	lw	v0,0(v0)
  4017f4:	00000000 	nop
  4017f8:	0062102a 	slt	v0,v1,v0 # 比较重排后链表前后两个数的大小，升序则爆炸
  4017fc:	10400015 	beqz	v0,401854 <phase_6+0x354>
  401800:	00000000 	nop
  401804:	0c10087c 	jal	4021f0 <explode_bomb>
  401808:	00000000 	nop
  40180c:	8fdc0010 	lw	gp,16(s8)
  401810:	10000010 	b	401854 <phase_6+0x354>
  401814:	00000000 	nop
  401818:	8fc20020 	lw	v0,32(s8)
  40181c:	00000000 	nop
  401820:	8c430000 	lw	v1,0(v0)
  401824:	8fc20020 	lw	v0,32(s8)
  401828:	00000000 	nop
  40182c:	8c420008 	lw	v0,8(v0)
  401830:	00000000 	nop
  401834:	8c420000 	lw	v0,0(v0)
  401838:	00000000 	nop
  40183c:	0043102a 	slt	v0,v0,v1 # 比较重排后链表前后两个数的大小，降序则爆炸
  401840:	10400004 	beqz	v0,401854 <phase_6+0x354>
  401844:	00000000 	nop
  401848:	0c10087c 	jal	4021f0 <explode_bomb>
  40184c:	00000000 	nop
  401850:	8fdc0010 	lw	gp,16(s8)
  401854:	8fc20020 	lw	v0,32(s8)
  401858:	00000000 	nop
  40185c:	8c420008 	lw	v0,8(v0)
  401860:	00000000 	nop
  401864:	afc20020 	sw	v0,32(s8)
  401868:	8fc2001c 	lw	v0,28(s8)
  40186c:	00000000 	nop
  401870:	24420001 	addiu	v0,v0,1 # i++
  401874:	afc2001c 	sw	v0,28(s8)
  401878:	8fc2001c 	lw	v0,28(s8)
  40187c:	00000000 	nop
  401880:	28420005 	slti	v0,v0,5 # i < 5
  401884:	1440ffcb 	bnez	v0,4017b4 <phase_6+0x2b4>
  401888:	00000000 	nop
  40188c:	03c0e821 	move	sp,s8
  401890:	8fbf005c 	lw	ra,92(sp)
  401894:	8fbe0058 	lw	s8,88(sp)
  401898:	27bd0060 	addiu	sp,sp,96
  40189c:	03e00008 	jr	ra
  4018a0:	00000000 	nop

keyNotes:for循环。首先输入6个整型数，这六个数必须在(0,7)开区间内且每个数都不能相同，实际就是123456的一个排列。若ID最后一位为奇数，则结果需按地址降序，若ID最后一位为偶数，则结果需按地址升序。对应为
6->01b0
5->00d4
4->03e5
3->012d
2->02d5
1->00fd
故若ID最后一位为奇数，则输入应为4 2 6 3 1 5，而若为偶数，则输入应倒序:5 1 3 6 2 4。
