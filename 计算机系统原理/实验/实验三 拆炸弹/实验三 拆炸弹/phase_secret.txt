00402264 <phase_defused>:
  402264:	27bdff88 	addiu	sp,sp,-120
  402268:	afbf0074 	sw	ra,116(sp)
  40226c:	afbe0070 	sw	s8,112(sp)
  402270:	03a0f021 	move	s8,sp
  402274:	3c1c0042 	lui	gp,0x42
  402278:	279cb190 	addiu	gp,gp,-20080
  40227c:	afbc0010 	sw	gp,16(sp)
  402280:	3c020041 	lui	v0,0x41
  402284:	8c433240 	lw	v1,12864(v0) //$v1存的是闯过了多少关
  402288:	24020006 	li	v0,6
  40228c:	14620039 	bne	v1,v0,402374 <phase_defused+0x110> //只有前六关过了才可以继续进行
  402290:	00000000 	nop
  402294:	8f828058 	lw	v0,-32680(gp)
  402298:	00000000 	nop
  40229c:	244400f0 	addiu	a0,v0,240 //$a0存的是答案4的起始地址
  4022a0:	3c020040 	lui	v0,0x40
  4022a4:	244328a8 	addiu	v1,v0,10408 //观察$v1为%d %s
  4022a8:	27c20068 	addiu	v0,s8,104
  4022ac:	00602821 	move	a1,v1
  4022b0:	00403021 	move	a2,v0
  4022b4:	27c20018 	addiu	v0,s8,24
  4022b8:	00403821 	move	a3,v0 //分别储存下来
  4022bc:	8f828084 	lw	v0,-32636(gp)
  4022c0:	00000000 	nop
  4022c4:	0040c821 	move	t9,v0
  4022c8:	0320f809 	jalr	t9 # 调用库中函数sscanf，跳转到.MIPS.stubs处执行，返回地址已自动存入ra寄存器
  4022cc:	00000000 	nop
  4022d0:	8fdc0010 	lw	gp,16(s8)
  4022d4:	00401821 	move	v1,v0
  4022d8:	24020002 	li	v0,2 # 判断sscanf读得的有效数据个数是否为2，判断$v0是否为2
  4022dc:	1462001d 	bne	v1,v0,402354 <phase_defused+0xf0> 
  4022e0:	00000000 	nop
  4022e4:	27c20018 	addiu	v0,s8,24 //$v0="austinpowers"
  4022e8:	00402021 	move	a0,v0 # $a0中存储着输入的字符
  4022ec:	3c020040 	lui	v0,0x40
  4022f0:	244528b0 	addiu	a1,v0,10416 # //$a1存的是输入的字符串 +8跳过了第一个数字和空格
  4022f4:	0c10073e 	jal	401cf8 <strings_not_equal> # 判断是否相等
  4022f8:	00000000 	nop
  4022fc:	8fdc0010 	lw	gp,16(s8)
  402300:	14400014 	bnez	v0,402354 <phase_defused+0xf0> //相等则继续，否则跳转至结束
  402304:	00000000 	nop
  402308:	3c020040 	lui	v0,0x40
  40230c:	244428c0 	addiu	a0,v0,10432
  402310:	8f828038 	lw	v0,-32712(gp)
  402314:	00000000 	nop
  402318:	0040c821 	move	t9,v0
  40231c:	0320f809 	jalr	t9
  402320:	00000000 	nop
  402324:	8fdc0010 	lw	gp,16(s8)
  402328:	3c020040 	lui	v0,0x40
  40232c:	244428e8 	addiu	a0,v0,10472
  402330:	8f828038 	lw	v0,-32712(gp)
  402334:	00000000 	nop
  402338:	0040c821 	move	t9,v0
  40233c:	0320f809 	jalr	t9
  402340:	00000000 	nop
  402344:	8fdc0010 	lw	gp,16(s8)
  402348:	0c100664 	jal	401990 <secret_phase> # 跳转至secret_phase
  40234c:	00000000 	nop
  402350:	8fdc0010 	lw	gp,16(s8)
  402354:	3c020040 	lui	v0,0x40
  402358:	24442920 	addiu	a0,v0,10528
  40235c:	8f828038 	lw	v0,-32712(gp)
  402360:	00000000 	nop
  402364:	0040c821 	move	t9,v0
  402368:	0320f809 	jalr	t9
  40236c:	00000000 	nop
  402370:	8fdc0010 	lw	gp,16(s8)
  402374:	03c0e821 	move	sp,s8
  402378:	8fbf0074 	lw	ra,116(sp)
  40237c:	8fbe0070 	lw	s8,112(sp)
  402380:	27bd0078 	addiu	sp,sp,120
  402384:	03e00008 	jr	ra
  402388:	00000000 	nop
  40238c:	00000000 	nop

004018a4 <fun7>:
  4018a4: 27bdffe0  addiu sp,sp,-32
  4018a8: afbf001c  sw  ra,28(sp)
  4018ac: afbe0018  sw  s8,24(sp)
  4018b0: 03a0f021  move  s8,sp
  4018b4: afc40020  sw  a0,32(s8)
  4018b8: afc50024  sw  a1,36(s8)
  4018bc: 8fc20020  lw  v0,32(s8)
  4018c0: 00000000  nop
  4018c4: 14400004  bnez  v0,4018d8 <fun7+0x34> # $v0($a0)不为0则继续，为0则函数结束
  4018c8: 00000000  nop
  4018cc: 2402ffff  li  v0,-1 # 设返回值为-1，即没有找到该值
  4018d0: 10000029  b 401978 <fun7+0xd4>
  4018d4: 00000000  nop
  4018d8: 8fc20020  lw  v0,32(s8) # 取出$a0中的值
  4018dc: 00000000  nop
  4018e0: 8c430000  lw  v1,0(v0) # $v1 = m[$a0]
  4018e4: 8fc20024  lw  v0,36(s8) # $v0 = $a1
  4018e8: 00000000  nop
  4018ec: 0043102a  slt v0,v0,v1 # 当$v0 < $v1时$v0 = 1，否则 = 0 。$v0 >= $v1时函数跳转，搜索左子树。
  4018f0: 1040000c  beqz  v0,401924 <fun7+0x80> # $v0 = 0则跳转
  4018f4: 00000000  nop
  4018f8: 8fc20020  lw  v0,32(s8)
  4018fc: 00000000  nop
  401900: 8c420004  lw  v0,4(v0) # 令fun7第一个参数为节点的左儿子的地址
  401904: 00000000  nop
  401908: 00402021  move  a0,v0
  40190c: 8fc50024  lw  a1,36(s8) #第二个参数不变
  401910: 0c100629  jal 4018a4 <fun7>
  401914: 00000000  nop
  401918: 00021040  sll v0,v0,0x1 # $v0左移一位
  40191c: 10000016  b 401978 <fun7+0xd4>
  401920: 00000000  nop
  401924: 8fc20020  lw  v0,32(s8)
  401928: 00000000  nop
  40192c: 8c430000  lw  v1,0(v0)
  401930: 8fc20024  lw  v0,36(s8)
  401934: 00000000  nop
  401938: 0062102a  slt v0,v1,v0 # $v1 >= $v0时函数跳转，即$v0 == $v1时找到节点，函数返回0
  40193c: 1040000d  beqz  v0,401974 <fun7+0xd0>
  401940: 00000000  nop
  401944: 8fc20020  lw  v0,32(s8)
  401948: 00000000  nop
  40194c: 8c420008  lw  v0,8(v0) # 令fun7第一个参数为节点的右儿子的地址
  401950: 00000000  nop
  401954: 00402021  move  a0,v0
  401958: 8fc50024  lw  a1,36(s8) # 第二个参数不变
  40195c: 0c100629  jal 4018a4 <fun7>
  401960: 00000000  nop
  401964: 00021040  sll v0,v0,0x1 # $v0左移一位
  401968: 24420001  addiu v0,v0,1 # $v0末位补1
  40196c: 10000002  b 401978 <fun7+0xd4>
  401970: 00000000  nop
  401974: 00001021  move  v0,zero
  401978: 03c0e821  move  sp,s8
  40197c: 8fbf001c  lw  ra,28(sp)
  401980: 8fbe0018  lw  s8,24(sp)
  401984: 27bd0020  addiu sp,sp,32
  401988: 03e00008  jr  ra
  40198c: 00000000  nop

00401990 <secret_phase>:
  401990:	27bdffd8 	addiu	sp,sp,-40
  401994:	afbf0024 	sw	ra,36(sp)
  401998:	afbe0020 	sw	s8,32(sp)
  40199c:	03a0f021 	move	s8,sp
  4019a0:	3c1c0042 	lui	gp,0x42
  4019a4:	279cb190 	addiu	gp,gp,-20080
  4019a8:	afbc0010 	sw	gp,16(sp)
  4019ac:	0c1007fb 	jal	401fec <read_line> # 输入
  4019b0:	00000000 	nop
  4019b4:	8fdc0010 	lw	gp,16(s8)
  4019b8:	afc2001c 	sw	v0,28(s8)
  4019bc:	8fc2001c 	lw	v0,28(s8)
  4019c0:	00000000 	nop
  4019c4:	00402021 	move	a0,v0
  4019c8:	00002821 	move	a1,zero
  4019cc:	2406000a 	li	a2,10
  4019d0:	8f828070 	lw	v0,-32656(gp)
  4019d4:	00000000 	nop
  4019d8:	0040c821 	move	t9,v0
  4019dc:	0320f809 	jalr	t9
  4019e0:	00000000 	nop
  4019e4:	8fdc0010 	lw	gp,16(s8)
  4019e8:	afc20018 	sw	v0,24(s8)
  4019ec:	8fc20018 	lw	v0,24(s8)
  4019f0:	00000000 	nop
  4019f4:	2442ffff 	addiu	v0,v0,-1 # $v0--
  4019f8:	2c4203e9 	sltiu	v0,v0,1001 # 判断[输入的值-1]($v0)是否小于1001，是则继续，否则引爆，因为若不符合的话一定查询不到，直接引爆。
  4019fc:	14400004 	bnez	v0,401a10 <secret_phase+0x80>
  401a00:	00000000 	nop
  401a04:	0c10087c 	jal	4021f0 <explode_bomb>
  401a08:	00000000 	nop
  401a0c:	8fdc0010 	lw	gp,16(s8)
  401a10:	3c020041 	lui	v0,0x41
  401a14:	24443184 	addiu	a0,v0,12676 # fun7的第一个参数0x413814 m[0x413814] = 0x24 = 36
  401a18:	8fc50018 	lw	a1,24(s8) # fun7的第二个参数，即输入的数
  401a1c:	0c100629 	jal	4018a4 <fun7> # 进入fun7
  401a20:	00000000 	nop
  401a24:	8fdc0010 	lw	gp,16(s8)
  401a28:	00401821 	move	v1,v0
  401a2c:	24020007 	li	v0,7
  401a30:	10620004 	beq	v1,v0,401a44 <secret_phase+0xb4> # fun7返回值为7 = 111B时才不会引爆
  401a34:	00000000 	nop
  401a38:	0c10087c 	jal	4021f0 <explode_bomb>
  401a3c:	00000000 	nop
  401a40:	8fdc0010 	lw	gp,16(s8)
  401a44:	3c020040 	lui	v0,0x40
  401a48:	244427b8 	addiu	a0,v0,10168
  401a4c:	8f828038 	lw	v0,-32712(gp)
  401a50:	00000000 	nop
  401a54:	0040c821 	move	t9,v0
  401a58:	0320f809 	jalr	t9
  401a5c:	00000000 	nop
  401a60:	8fdc0010 	lw	gp,16(s8)
  401a64:	0c100899 	jal	402264 <phase_defused>
  401a68:	00000000 	nop
  401a6c:	8fdc0010 	lw	gp,16(s8)
  401a70:	03c0e821 	move	sp,s8
  401a74:	8fbf0024 	lw	ra,36(sp)
  401a78:	8fbe0020 	lw	s8,32(sp)
  401a7c:	27bd0028 	addiu	sp,sp,40
  401a80:	03e00008 	jr	ra
  401a84:	00000000 	nop


keyNotes:在炸弹四答案后面加上字符串austinpowers即可进入隐藏炸弹,二叉搜索树的递归查询，输入数值x，执行find（x），返回得到根节点到值为x的节点的路径。炸弹要求返回值为7=111B，即根节点的右儿子节点的右儿子节点的右儿子节点，该节点值为1001。因此输入1001即可。
		  36

​    	     8          50

         ​ 6     22   45    107

       1   7 20  35 40  47 99 1001