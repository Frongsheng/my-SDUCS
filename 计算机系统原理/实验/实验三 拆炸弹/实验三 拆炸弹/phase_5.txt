gdb操作
b* 0x004014d0
r
x $a0
x $a1
b* 0x00401484
r
x /s $v0
ni
x /s $v0

004013e8 <phase_5>:
  4013e8:	27bdffb8 	addiu	sp,sp,-72
  4013ec:	afbf0044 	sw	ra,68(sp)
  4013f0:	afbe0040 	sw	s8,64(sp)
  4013f4:	03a0f021 	move	s8,sp
  4013f8:	afc40048 	sw	a0,72(s8) //$a0为输入的字符串，将其存入栈中
  4013fc:	8fc40048 	lw	a0,72(s8)
  401400:	0c10071e 	jal	401c78 <string_length>
  401404:	00000000 	nop
  401408:	00401821 	move	v1,v0
  40140c:	24020006 	li	v0,6
  401410:	10620003 	beq	v1,v0,401420 <phase_5+0x38> // 输入字符串长度$v1 != 6则引爆
  401414:	00000000 	nop
  401418:	0c10087c 	jal	4021f0 <explode_bomb>
  40141c:	00000000 	nop
  401420:	afc00018 	sw	zero,24(s8) //i = 0
  401424:	10000020 	b	4014a8 <phase_5+0xc0>
  401428:	00000000 	nop
  40142c:	8fc20018 	lw	v0,24(s8) //读得i
  401430:	8fc30018 	lw	v1,24(s8) //读得i
  401434:	8fc40048 	lw	a0,72(s8) //从栈中取出输入的字符串（从0开始编号）
  401438:	00000000 	nop
  40143c:	00831821 	addu	v1,a0,v1
  401440:	80630000 	lb	v1,0(v1) //读取输入字符串的第i个字符
  401444:	00000000 	nop
  401448:	306300ff 	andi	v1,v1,0xff
  40144c:	3063000f 	andi	v1,v1,0xf //取字符转化为二进制ascii码（1byte=8bit）的后四位
  401450:	00021080 	sll	v0,v0,0x2 //将i拓至1 int型变量长度
  401454:	27c40018 	addiu	a0,s8,24 //读得i的地址
  401458:	00821021 	addu	v0,a0,v0
  40145c:	ac43000c 	sw	v1,12(v0) //将字符后四位存入m[$s8 + 36 + i * 4]
  401460:	8fc40018 	lw	a0,24(s8) //读得i
  401464:	8fc20018 	lw	v0,24(s8) //读得i
  401468:	00000000 	nop
  40146c:	00021080 	sll	v0,v0,0x2 //将i拓至1 int型变量长度
  401470:	27c30018 	addiu	v1,s8,24 //读得i的地址
  401474:	00621021 	addu	v0,v1,v0
  401478:	8c43000c 	lw	v1,12(v0) //读得字符后四位，存入$v1中
  40147c:	3c020041 	lui	v0,0x41
  401480:	244230ec 	addiu	v0,v0,12524 //获取存储的字符串S（从0开始编号)的位置，得到$v0 = isrveawhobpnutfg
  401484:	00621021 	addu	v0,v1,v0 //得到第$v1个字符的内存地址
  401488:	80430000 	lb	v1,0(v0) //得到第$v1（输入字符串的第i个字符的后四位，即ASCII码的b3b2b1b0）个字符
  40148c:	27c20018 	addiu	v0,s8,24
  401490:	00441021 	addu	v0,v0,a0
  401494:	a0430004 	sb	v1,4(v0) //将获得的字符存入m[$s8 + 28 + i]
  401498:	8fc20018 	lw	v0,24(s8) //读得i
  40149c:	00000000 	nop
  4014a0:	24420001 	addiu	v0,v0,1 //i++
  4014a4:	afc20018 	sw	v0,24(s8)
  4014a8:	8fc20018 	lw	v0,24(s8)
  4014ac:	00000000 	nop
  4014b0:	28420006 	slti	v0,v0,6 //$v0 = ($v0 < 6 ? 1 : 0)，为1再循环一次，即i < 6
  4014b4:	1440ffdd 	bnez	v0,40142c <phase_5+0x44>
  4014b8:	00000000 	nop
  4014bc:	a3c00022 	sb	zero,34(s8) //将字符串尾设为'\0'
  4014c0:	27c2001c 	addiu	v0,s8,28
  4014c4:	00402021 	move	a0,v0 //从内存中获取 依靠映射从存储的字符串S中得到的字符串
  4014c8:	3c020040 	lui	v0,0x40
  4014cc:	244527b0 	addiu	a1,v0,10160 //从内存中获取用来比较的字符串
  4014d0:	0c10073e 	jal	401cf8 <strings_not_equal> //比较$a0,$a1，不相等则跳转爆炸
  4014d4:	00000000 	nop
  4014d8:	10400003 	beqz	v0,4014e8 <phase_5+0x100>
  4014dc:	00000000 	nop
  4014e0:	0c10087c 	jal	4021f0 <explode_bomb>
  4014e4:	00000000 	nop
  4014e8:	03c0e821 	move	sp,s8
  4014ec:	8fbf0044 	lw	ra,68(sp)
  4014f0:	8fbe0040 	lw	s8,64(sp)
  4014f4:	27bd0048 	addiu	sp,sp,72
  4014f8:	03e00008 	jr	ra
  4014fc:	00000000 	nop

keyNotes:数组操作。要求输入一段长度为6的字符串，对输入字符串中的第i个字符，取出其8位ascii码的最后四位，计为一个0-15的十进制数x，程序存储的长度为16的字符串S=“isrveawhobpnutfg”，将S[x]映射到res[i]，最后比对res数组是否为"giants"，不是则爆炸。
输入的字符串可以为opekma